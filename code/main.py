import arrow
import pprint

from parser import *

DATA_FILE = 'data.txt'
THRES_SECS = 30
ALPHA = 1

class Active:
    def __init__(self, start, end, name):
        self.name = name
        self.start = arrow.get(start)
        self.end = arrow.get(end)

    def __repr__(self):
	return (self.name + ': ' + str(self.start.format('YYYY-MM-DD HH:mm:ss')) + 
                '---> ' + str(self.end.format('YYYY-MM-DD HH:mm:ss')))

def get_usage_timeline(data):
    usage = {}
    for name in data:
        statuses = data[name]
        if not statuses[0].isOnline:
            statuses = statuses[1:]
        if statuses[-1].isOnline:
            statuses = statuses[:-1]

        timeline = []
        for i in range(0, len(statuses), 2):
            timeline.append(Active(statuses[i].time, statuses[i+1].time, name))
            
        usage[name] = timeline

    return usage

def compare_actives(a, b):
    if a.start > b.start:
       return 1
    if a.start < b.start:
       return -1
    if a.end > b.end:
       return 1
    if a.end < b.end:
       return -1
    return 0

# Assumes act1 < act2
def intersect(act1, act2):
    return (act1.end.replace(seconds=+THRES_SECS) > act2.start)

def process_timeline(timeline):
    matches = []
    i = -1
    while i < len(timeline) - 2:
        i += 1
        if timeline[i].name == timeline[i+1].name:
            continue
        if not intersect(timeline[i], timeline[i+1]):
            continue
        last_1 = i		# Last entry for first name in connected component
        last_2 = i + 1		# Last entry for second name in connected component
        l = i + 2
        num_1 = 1		# Number of first name's entries in connected component
        num_2 = 1		# Number of second name's entries in connected component
        while l < len(timeline):
            if timeline[l].name == timeline[i].name:
                if intersect(timeline[last_2], timeline[l]):
                    last_1 = l
                    num_1 += 1
            else:
                if intersect(timeline[last_1], timeline[l]):
                    last_2 = l
                    num_2 += 1
            if not (intersect(timeline[last_1], timeline[l]) or
                    intersect(timeline[last_2], timeline[l])):
                break
            l += 1

        p_talking = 1 - 2**(-ALPHA*(num_1 + num_2)/2)
        matches.append((timeline[i].start, timeline[max(last_1, last_2)].end, p_talking))

        i = max(last_1, last_2)
       
    return matches

def humanize(match):
    text = ('\t' + str(match[0].format('YYYY-MM-DD HH:mm:ss')) +
           ' ....... ' + str(match[1].format('YYYY-MM-DD HH:mm:ss')))
    text += '   Prob = ' + str(match[2]) + '\n'
    return text

def find_matches(usage):
    names = usage.keys()
    print names
    for i in range(len(names) - 1):
        for j in range(i + 1, len(names)):
            timeline = usage[names[i]] + usage[names[j]]
            timeline.sort(cmp=compare_actives)

            #pprint.pprint(timeline)
            matches = process_timeline(timeline)
	    if len(matches) == 0:
	        continue
	    print names[i] + ' <---> ' + names[j]
	    matches = [humanize(match) for match in matches]
	    print ''.join(matches)

def main():
    data = DataParser(DATA_FILE)
    usage = get_usage_timeline(data.metadata)
    #pprint.pprint(usage)
    find_matches(usage)


if __name__ == '__main__':
    main()
    
